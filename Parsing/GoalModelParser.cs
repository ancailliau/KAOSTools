// Machine generated by peg-sharp 0.3.427.0 from GoalModelParser.peg.
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.Serialization;
using System.Security.Permissions;

[Serializable]
internal sealed class ParserException : Exception
{
	public ParserException()
	{
	}
	
	public ParserException(string message) : base(message)
	{
	}
	
	public ParserException(int line, int col, string file, string message) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."))
	{
	}
	
	public ParserException(int line, int col, string file, string format, params object[] args) : this(line, col, file, string.Format(format, args))
	{
	}
	
	public ParserException(int line, int col, string file, string message, Exception inner) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."), inner)
	{
	}
	
	[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
	private ParserException(SerializationInfo info, StreamingContext context) : base(info, context)
	{
	}
}

// Thread safe if Parser instances are not shared across threads.
internal sealed partial class GoalModelParser
{
	public GoalModelParser()
	{
		m_nonterminals.Add("Start", new ParseMethod[]{this.DoParseStartRule});
		m_nonterminals.Add("Elements", new ParseMethod[]{this.DoParseElementsRule});
		m_nonterminals.Add("Import", new ParseMethod[]{this.DoParseImportRule});
		m_nonterminals.Add("Predicate", new ParseMethod[]{this.DoParsePredicateRule});
		m_nonterminals.Add("System", new ParseMethod[]{this.DoParseSystemRule});
		m_nonterminals.Add("Goal", new ParseMethod[]{this.DoParseGoalRule});
		m_nonterminals.Add("DomProp", new ParseMethod[]{this.DoParseDomPropRule});
		m_nonterminals.Add("Obstacle", new ParseMethod[]{this.DoParseObstacleRule});
		m_nonterminals.Add("Agent", new ParseMethod[]{this.DoParseAgentRule});
		m_nonterminals.Add("DomHyp", new ParseMethod[]{this.DoParseDomHypRule});
		m_nonterminals.Add("Entity", new ParseMethod[]{this.DoParseEntityRule});
		m_nonterminals.Add("Type", new ParseMethod[]{this.DoParseTypeRule});
		m_nonterminals.Add("Association", new ParseMethod[]{this.DoParseAssociationRule});
		m_nonterminals.Add("GoalAttribute", new ParseMethod[]{this.DoParseGoalAttributeRule});
		m_nonterminals.Add("DomPropAttribute", new ParseMethod[]{this.DoParseDomPropAttributeRule});
		m_nonterminals.Add("DomHypAttribute", new ParseMethod[]{this.DoParseDomHypAttributeRule});
		m_nonterminals.Add("ObstacleAttribute", new ParseMethod[]{this.DoParseObstacleAttributeRule});
		m_nonterminals.Add("AgentAttribute", new ParseMethod[]{this.DoParseAgentAttributeRule});
		m_nonterminals.Add("PredicateAttribute", new ParseMethod[]{this.DoParsePredicateAttributeRule});
		m_nonterminals.Add("SystemAttribute", new ParseMethod[]{this.DoParseSystemAttributeRule});
		m_nonterminals.Add("EntityAttribute", new ParseMethod[]{this.DoParseEntityAttributeRule});
		m_nonterminals.Add("TypeAttribute", new ParseMethod[]{this.DoParseTypeAttributeRule});
		m_nonterminals.Add("AssociationAttribute", new ParseMethod[]{this.DoParseAssociationAttributeRule});
		m_nonterminals.Add("IdAttribute", new ParseMethod[]{this.DoParseIdAttributeRule});
		m_nonterminals.Add("NameAttribute", new ParseMethod[]{this.DoParseNameAttributeRule});
		m_nonterminals.Add("Signature", new ParseMethod[]{this.DoParseSignatureRule});
		m_nonterminals.Add("FormalSpec", new ParseMethod[]{this.DoParseFormalSpecRule});
		m_nonterminals.Add("Definition", new ParseMethod[]{this.DoParseDefinitionRule});
		m_nonterminals.Add("AgentTypeAttribute", new ParseMethod[]{this.DoParseAgentTypeAttributeRule});
		m_nonterminals.Add("RDS", new ParseMethod[]{this.DoParseRDSRule});
		m_nonterminals.Add("Probability", new ParseMethod[]{this.DoParseProbabilityRule});
		m_nonterminals.Add("RefinedByObstacle", new ParseMethod[]{this.DoParseRefinedByObstacleRule});
		m_nonterminals.Add("RefinedByGoal", new ParseMethod[]{this.DoParseRefinedByGoalRule});
		m_nonterminals.Add("ObstructedBy", new ParseMethod[]{this.DoParseObstructedByRule});
		m_nonterminals.Add("AssignedTo", new ParseMethod[]{this.DoParseAssignedToRule});
		m_nonterminals.Add("ResolvedBy", new ParseMethod[]{this.DoParseResolvedByRule});
		m_nonterminals.Add("Alternative", new ParseMethod[]{this.DoParseAlternativeRule});
		m_nonterminals.Add("Attribute", new ParseMethod[]{this.DoParseAttributeRule});
		m_nonterminals.Add("Argument", new ParseMethod[]{this.DoParseArgumentRule});
		m_nonterminals.Add("Link", new ParseMethod[]{this.DoParseLinkRule});
		m_nonterminals.Add("IsA", new ParseMethod[]{this.DoParseIsARule});
		m_nonterminals.Add("Multiplicity", new ParseMethod[]{this.DoParseMultiplicityRule});
		m_nonterminals.Add("MultiplicityLowerBound", new ParseMethod[]{this.DoParseMultiplicityLowerBoundRule});
		m_nonterminals.Add("MultiplicityUpperBound", new ParseMethod[]{this.DoParseMultiplicityUpperBoundRule});
		m_nonterminals.Add("IdOrNameOrObstacle", new ParseMethod[]{this.DoParseIdOrNameOrObstacleRule});
		m_nonterminals.Add("IdOrNameOrGoal", new ParseMethod[]{this.DoParseIdOrNameOrGoalRule});
		m_nonterminals.Add("IdOrNameOrAgent", new ParseMethod[]{this.DoParseIdOrNameOrAgentRule});
		m_nonterminals.Add("IdOrNameOrSystem", new ParseMethod[]{this.DoParseIdOrNameOrSystemRule});
		m_nonterminals.Add("IdOrName", new ParseMethod[]{this.DoParseIdOrNameRule});
		m_nonterminals.Add("Identifier", new ParseMethod[]{this.DoParseIdentifierRule});
		m_nonterminals.Add("Name", new ParseMethod[]{this.DoParseNameRule});
		m_nonterminals.Add("String", new ParseMethod[]{this.DoParseStringRule});
		m_nonterminals.Add("Float", new ParseMethod[]{this.DoParseFloatRule});
		m_nonterminals.Add("Formula", new ParseMethod[]{this.DoParseFormulaRule});
		m_nonterminals.Add("StrongBinary", new ParseMethod[]{this.DoParseStrongBinaryRule});
		m_nonterminals.Add("Binary", new ParseMethod[]{this.DoParseBinaryRule});
		m_nonterminals.Add("TemporalBinary", new ParseMethod[]{this.DoParseTemporalBinaryRule});
		m_nonterminals.Add("And", new ParseMethod[]{this.DoParseAndRule});
		m_nonterminals.Add("Or", new ParseMethod[]{this.DoParseOrRule});
		m_nonterminals.Add("Unary", new ParseMethod[]{this.DoParseUnaryRule});
		m_nonterminals.Add("Atom", new ParseMethod[]{this.DoParseAtomRule});
		m_nonterminals.Add("SingleQuoteString", new ParseMethod[]{this.DoParseSingleQuoteStringRule});
		m_nonterminals.Add("Number", new ParseMethod[]{this.DoParseNumberRule});
		m_nonterminals.Add("S", new ParseMethod[]{this.DoParseSRule});
		m_nonterminals.Add("Space", new ParseMethod[]{this.DoParseSpaceRule});
		m_nonterminals.Add("Comment", new ParseMethod[]{this.DoParseCommentRule});
		OnCtorEpilog();
	}
	
	public KAOSTools.Parsing.ParsedElement Parse(string input)
	{
		return DoParseFile(input, null);
	}
	
	// File is used for error reporting.
	public KAOSTools.Parsing.ParsedElement Parse(string input, string file)
	{
		return DoParseFile(input, file);
	}
	
	#region Non-Terminal Parse Methods
	// Start := S Elements S
	private State DoParseStartRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Elements");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Elements := ((System / Predicate / Goal / DomProp / Obstacle / Agent / Import / DomHyp / Entity / Type / Association) S)*
	private State DoParseElementsRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 0, 2147483647,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "System");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Predicate");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Goal");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "DomProp");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Obstacle");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Agent");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Import");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "DomHyp");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Entity");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Type");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Association");});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildElements (results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Import := 'import' S '"' String '"'
	private State DoParseImportRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "import");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "String");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = Import(results[2].Text);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Predicate := ('declare' / 'override') S 'predicate' S (PredicateAttribute S)* 'end'
	private State DoParsePredicateRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "predicate");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "PredicateAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildPredicate(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// System := ('declare' / 'override') S 'system' S (SystemAttribute S)* 'end'
	private State DoParseSystemRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "system");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "SystemAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildSystem(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Goal := ('declare' / 'override') S 'goal' S (GoalAttribute S)* 'end'
	private State DoParseGoalRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "goal");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "GoalAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildGoal(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// DomProp := ('declare' / 'override') S ('domainproperty' / 'domprop') S (DomPropAttribute S)* 'end'
	private State DoParseDomPropRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "domainproperty");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "domprop");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "DomPropAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildDomainProperty(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Obstacle := ('declare' / 'override') S 'obstacle' S (ObstacleAttribute S)* 'end'
	private State DoParseObstacleRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "obstacle");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ObstacleAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildObstacle(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Agent := ('declare' / 'override') S 'agent' S (AgentAttribute S)* 'end'
	private State DoParseAgentRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "agent");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "AgentAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildAgent(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// DomHyp := ('declare' / 'override') S ('domainhypothesis' / 'domhyp') S (DomHypAttribute S)* 'end'
	private State DoParseDomHypRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "domainhypothesis");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "domhyp");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "DomHypAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildDomainHypothesis(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Entity := ('declare' / 'override') S (('software' / 'environment' / 'shared') S)? ('entity' / 'object') S (EntityAttribute S)* 'end'
	private State DoParseEntityRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "software");},
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "environment");},
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "shared");});},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "entity");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "object");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "EntityAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildEntity(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Type := ('declare' / 'override') S 'type' S (TypeAttribute S)* 'end'
	private State DoParseTypeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "TypeAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildType(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Association := ('declare' / 'override') S ('association' / 'relation') S (AssociationAttribute S)* 'end'
	private State DoParseAssociationRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "association");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "relation");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "AssociationAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildAssociation(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// GoalAttribute := IdAttribute / NameAttribute / Definition / FormalSpec / RefinedByGoal / ObstructedBy / AssignedTo / RDS
	private State DoParseGoalAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "FormalSpec");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RefinedByGoal");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ObstructedBy");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "AssignedTo");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RDS");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// DomPropAttribute := IdAttribute / NameAttribute / Definition / FormalSpec / Probability
	private State DoParseDomPropAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "FormalSpec");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Probability");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// DomHypAttribute := IdAttribute / NameAttribute / Definition
	private State DoParseDomHypAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ObstacleAttribute := IdAttribute / NameAttribute / Definition / FormalSpec / RefinedByObstacle / ResolvedBy / Probability
	private State DoParseObstacleAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "FormalSpec");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RefinedByObstacle");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ResolvedBy");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Probability");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// AgentAttribute := IdAttribute / NameAttribute / Definition / AgentTypeAttribute
	private State DoParseAgentAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "AgentTypeAttribute");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PredicateAttribute := IdAttribute / NameAttribute / Definition / Signature / Argument / FormalSpec
	private State DoParsePredicateAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Signature");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Argument");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "FormalSpec");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// SystemAttribute := IdAttribute / NameAttribute / Definition / Alternative
	private State DoParseSystemAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Alternative");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// EntityAttribute := IdAttribute / NameAttribute / Definition / Attribute / IsA
	private State DoParseEntityAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Attribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IsA");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// TypeAttribute := IdAttribute / NameAttribute / Definition
	private State DoParseTypeAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// AssociationAttribute := IdAttribute / NameAttribute / Definition / Attribute / Link
	private State DoParseAssociationAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Attribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Link");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// IdAttribute := 'id' S Identifier
	private State DoParseIdAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "id");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildIdentifierAttribute(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// NameAttribute := 'name' S '"' String '"'
	private State DoParseNameAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "name");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "String");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildNameAttribute(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Signature := 'signature' S '"' String '"'
	private State DoParseSignatureRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "signature");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "String");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildSignature(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// FormalSpec := 'formalspec' S '"' Formula '"'
	private State DoParseFormalSpecRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "formalspec");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Formula");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildFormalSpec(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Definition := 'definition' S '"' String? '"'
	private State DoParseDefinitionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "String");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildDefinition(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// AgentTypeAttribute := 'type' S ('software' / 'environment')
	private State DoParseAgentTypeAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "software");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "environment");});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildAgentTypeAttribute (results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// RDS := 'rds' S Float
	private State DoParseRDSRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "rds");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Float");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildRDS(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Probability := ('probability' / 'eps') S Float
	private State DoParseProbabilityRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "probability");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "eps");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Float");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildProbability(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// RefinedByObstacle := 'refinedby' S IdOrNameOrObstacle (S ',' S IdOrNameOrObstacle)*
	private State DoParseRefinedByObstacleRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "refinedby");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrNameOrObstacle");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "IdOrNameOrObstacle");});});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildRefinedBy(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// RefinedByGoal := 'refinedby' ('[' S IdOrName S ']')? S IdOrNameOrGoal (S ',' S IdOrNameOrGoal)*
	private State DoParseRefinedByGoalRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "refinedby");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "[");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "IdOrName");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "]");});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrNameOrGoal");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "IdOrNameOrGoal");});});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildRefinedBy(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ObstructedBy := 'obstructedby' S IdOrNameOrObstacle
	private State DoParseObstructedByRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "obstructedby");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrNameOrObstacle");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildObstructedBy(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// AssignedTo := 'assignedto' ('[' S IdOrName S ']')? S IdOrNameOrAgent (S ',' S IdOrNameOrAgent)*
	private State DoParseAssignedToRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "assignedto");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "[");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "IdOrName");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "]");});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrNameOrAgent");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "IdOrNameOrAgent");});});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildAssignedTo(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// ResolvedBy := 'resolvedby' S IdOrNameOrGoal
	private State DoParseResolvedByRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "resolvedby");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrNameOrGoal");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildResolvedBy(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Alternative := 'alternative' S IdOrNameOrSystem
	private State DoParseAlternativeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "alternative");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrNameOrSystem");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildAlternative(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Attribute := 'attribute' S Name S (':' S IdOrName)?
	private State DoParseAttributeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "attribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Name");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ":");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "IdOrName");});});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildAttribute(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Argument := 'argument' S Name S (':' S IdOrName)?
	private State DoParseArgumentRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "argument");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Name");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ":");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "IdOrName");});});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildArgument(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Link := 'link' S Multiplicity? S IdOrName
	private State DoParseLinkRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "link");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Multiplicity");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrName");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildLink(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// IsA := 'is' S IdOrName
	private State DoParseIsARule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "is");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrName");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildIsA(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Multiplicity := '(' S MultiplicityLowerBound S ('..' S MultiplicityUpperBound S)? ')'
	private State DoParseMultiplicityRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "MultiplicityLowerBound");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "..");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "MultiplicityUpperBound");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildMultiplicity(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// MultiplicityLowerBound := [0-9] / 'M' / 'N'
	private State DoParseMultiplicityLowerBoundRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, string.Empty, "09", null, "[0-9]");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "M");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "N");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// MultiplicityUpperBound := [0-9] / 'M' / 'N' / '*'
	private State DoParseMultiplicityUpperBoundRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, string.Empty, "09", null, "[0-9]");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "M");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "N");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "*");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// IdOrNameOrObstacle := Obstacle / IdOrName
	private State DoParseIdOrNameOrObstacleRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Obstacle");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrName");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "id or name";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdOrNameOrGoal := Goal / DomProp / DomHyp / IdOrName
	private State DoParseIdOrNameOrGoalRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Goal");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DomProp");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DomHyp");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrName");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "id or name";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdOrNameOrAgent := Agent / IdOrName
	private State DoParseIdOrNameOrAgentRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Agent");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrName");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "id or name";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdOrNameOrSystem := System / IdOrName
	private State DoParseIdOrNameOrSystemRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "System");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdOrName");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = results[0].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "id or name";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IdOrName := ('"' String '"') / Identifier
	private State DoParseIdOrNameRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "\"");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "String");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "\"");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildIdOrName(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "id or name";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Identifier := [$_-]? ([a-zA-Z0-9] [$_-a-zA-Z0-9]*)
	private State DoParseIdentifierRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, "$_-", string.Empty, null, "[$_-]");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "azAZ09", null, "[a-zA-Z0-9]");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, "$_-", "azAZ09", null, "[$_-a-zA-Z0-9]");});});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildIdentifier(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Name := '"' String '"'
	private State DoParseNameRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "String");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildName(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// String := ('""' / [^\"])+
	private State DoParseStringRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 1, 2147483647,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "\"\"");},
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "\"", string.Empty, null, "[^\"]");});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = null;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "string";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Float := ('.' [0-9]+) / ([0-9]+ ('.' [0-9]+)?)
	private State DoParseFloatRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ".");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 1, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, string.Empty, "09", null, "[0-9]");});});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 1, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, string.Empty, "09", null, "[0-9]");});},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ".");},
						delegate (State s4, List<Result> r4) {return DoRepetition(s4, r4, 1, 2147483647,
							delegate (State s5, List<Result> r5) {return DoParseRange(s5, r5, false, string.Empty, "09", null, "[0-9]");});});});});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = null;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "float";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Formula := ('forall' S Identifier S ':' S Identifier (',' S Identifier S ':' S Identifier)* S '.' S Formula) / ('exists' S Identifier S ':' S Identifier (',' S Identifier S ':' S Identifier)* S '.' S Formula) / StrongBinary
	private State DoParseFormulaRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "forall");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ":");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 2147483647,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ",");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ":");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ".");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "exists");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ":");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 2147483647,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ",");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ":");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ".");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "StrongBinary");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildFormula(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// StrongBinary := ('when' S Binary S 'then' S Formula) / Binary
	private State DoParseStrongBinaryRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "when");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Binary");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "then");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Binary");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildStrongBinary(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Binary := ('if' S TemporalBinary S 'then' S Formula) / (TemporalBinary S 'iff' S Formula) / TemporalBinary
	private State DoParseBinaryRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "if");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TemporalBinary");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "then");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TemporalBinary");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "iff");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "TemporalBinary");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildBinary(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// TemporalBinary := (And S 'until' S Formula) / (And S 'release' S Formula) / (And S 'unless' S Formula) / And
	private State DoParseTemporalBinaryRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "And");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "until");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "And");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "release");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "And");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "unless");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "And");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildTemporalBinary(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// And := (Or S 'and' S Formula) / Or
	private State DoParseAndRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Or");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "and");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Or");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildAnd(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Or := (Unary S 'or' S Formula) / Unary
	private State DoParseOrRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Unary");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "or");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Unary");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildOr(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Unary := ('not' S Formula) / ('next' S Formula) / (('sooner-or-later' / 'eventually') S Formula) / (('always' / 'globally') S Formula) / Atom
	private State DoParseUnaryRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "not");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "next");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "sooner-or-later");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "eventually");});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "always");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "globally");});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Atom");});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildUnary(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Atom := ('(' S Identifier (S ',' S Identifier)* S ')' S 'in' S Identifier) / (Identifier (S '(' S Identifier (S ',' S Identifier)* S ')')) / (Identifier '.' Identifier (S ('==' / '!=' / '>=' / '<=' / '>' / '<') S ((Identifier '.' Identifier) / ('\'' SingleQuoteString '\'') / Number))?) / Identifier / ('(' S Formula S ')')
	private State DoParseAtomRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "(");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 2147483647,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ",");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ")");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "in");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "(");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Identifier");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 2147483647,
						delegate (State s4, List<Result> r4) {return DoSequence(s4, r4,
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "S");},
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, ",");},
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "S");},
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "Identifier");});});},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ")");});});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ".");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoChoice(s4, r4,
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, "==");},
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, "!=");},
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, ">=");},
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, "<=");},
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, ">");},
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, "<");});},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoChoice(s4, r4,
							delegate (State s5, List<Result> r5) {return DoSequence(s5, r5,
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "Identifier");},
								delegate (State s6, List<Result> r6) {return DoParseLiteral(s6, r6, ".");},
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "Identifier");});},
							delegate (State s5, List<Result> r5) {return DoSequence(s5, r5,
								delegate (State s6, List<Result> r6) {return DoParseLiteral(s6, r6, "\'");},
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "SingleQuoteString");},
								delegate (State s6, List<Result> r6) {return DoParseLiteral(s6, r6, "\'");});},
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "Number");});});});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "(");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ")");});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = BuildAtom(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// SingleQuoteString := ('\'\'' / [^'])+
	private State DoParseSingleQuoteStringRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 1, 2147483647,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "\'\'");},
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "'", string.Empty, null, "[^']");});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = null;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "string";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Number := ('.' [0-9]+) / ([0-9]+ ('.' [0-9]+)?)
	private State DoParseNumberRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ".");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 1, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, string.Empty, "09", null, "[0-9]");});});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 1, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, string.Empty, "09", null, "[0-9]");});},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ".");},
						delegate (State s4, List<Result> r4) {return DoRepetition(s4, r4, 1, 2147483647,
							delegate (State s5, List<Result> r5) {return DoParseRange(s5, r5, false, string.Empty, "09", null, "[0-9]");});});});});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			value = null;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "string";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// S := (Space* Comment+ Space*)+ / Space*
	private State DoParseSRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 2147483647,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Space");});},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 1, 2147483647,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Comment");});},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 2147483647,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Space");});});});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Space");});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			text = null;
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Space := [ \t\r\n]
	private State DoParseSpaceRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParseRange(_state, results, false, " \t\r\n", string.Empty, null, "[ \t\r\n]");
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "whitespace";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Comment := '#' [^\r\n]*
	private State DoParseCommentRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "#");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "\r\n", string.Empty, null, "[^\r\n]");});});
		
		if (_state.Parsed)
		{
			KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			text = null;
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	#endregion
	
	#region Private Helper Methods
	partial void OnCtorEpilog();
	partial void OnParseProlog();
	partial void OnParseEpilog(State state);
	
	private KAOSTools.Parsing.ParsedElement DoParseFile(string input, string file)
	{
		m_file = file;
		m_input = m_file;				// we need to ensure that m_file is used or we will (in some cases) get a compiler warning
		m_input = input + "\x0";	// add a sentinel so we can avoid range checks
		m_cache.Clear();
		
		State state = new State(0, true);
		List<Result> results = new List<Result>();
		
		OnParseProlog();
		state = DoParse(state, results, "Start");
		
		int i = state.Index;
		if (!state.Parsed)
			DoThrow(state.Errors.Index, state.Errors.ToString());
		else if (i < input.Length)
			if (state.Errors.Expected.Length > 0)
				DoThrow(state.Errors.Index, state.Errors.ToString());
			else
				DoThrow(state.Errors.Index, "Not all input was consumed starting from '" + input.Substring(i, Math.Min(16, input.Length - i)) + "'");
		OnParseEpilog(state);
		
		return results[0].Value;
	}
	
	public string DoEscapeAll(string s)
	{
		System.Text.StringBuilder builder = new System.Text.StringBuilder(s.Length);
		
		foreach (char ch in s)
		{
			if (ch == '\n')
				builder.Append("\\n");
			
			else if (ch == '\r')
				builder.Append("\\r");
			
			else if (ch == '\t')
				builder.Append("\\t");
			
			else if (ch < ' ')
				builder.AppendFormat("\\x{0:X2}", (int) ch);
			
			else
				builder.Append(ch);
		}
		
		return builder.ToString();
	}
	
	// This is normally only used for error handling so it doesn't need to be too
	// fast. If it somehow does become a bottleneck for some parsers they can
	// replace it with the custom-methods setting.
	private int DoGetLine(int index)
	{
		int line = 1;
		
		int i = 0;
		while (i <= index)
		{
			char ch = m_input[i++];
			
			if (ch == '\r' && m_input[i] == '\n')
			{
				++i;
				++line;
			}
			else if (ch == '\r')
			{
				++line;
			}
			else if (ch == '\n')
			{
				++line;
			}
		}
		
		return line;
	}
	
	private int DoGetCol(int index)
	{
		int start = index;
		
		while (index > 0 && m_input[index - 1] != '\n' && m_input[index - 1] != '\r')
		{
			--index;
		}
		
		return start - index + 1;
	}
	
	private void DoThrow(int index, string format, params object[] args)
	{
		int line = DoGetLine(index);
		int col = DoGetCol(index);
	
		// We need this retarded if or string.Format will throw an error if it
		// gets a format string like "Expected { or something".
		if (args != null && args.Length > 0)
			throw new ParserException(line, col, m_file, DoEscapeAll(string.Format(format, args)));
		else
			throw new ParserException(line, col, m_file, DoEscapeAll(format));
	}
	
	private State DoParseLiteral(State state, List<Result> results, string literal)
	{
		int j = state.Index;
		
		for (int i = 0; i < literal.Length; ++i)
		{
			if (m_input[j + i] != literal[i])
			{
				return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, literal)));
			}
		}
		
		int k = j + literal.Length;
		
		results.Add(new Result(this, j, literal.Length, m_input, default(KAOSTools.Parsing.ParsedElement)));
		state = new State(k, true, state.Errors);
		
		return state;
	}
	
	private State DoParse(State state, List<Result> results, string nonterminal)
	{
		State start = state;
		
		CacheValue cache;
		CacheKey key = new CacheKey(nonterminal, start.Index);
		if (!m_cache.TryGetValue(key, out cache))
		{
			ParseMethod[] methods = m_nonterminals[nonterminal];
			
			int oldCount = results.Count;
			state = DoChoice(state, results, methods);
			
			bool hasResult = state.Parsed && results.Count > oldCount;
			KAOSTools.Parsing.ParsedElement value = hasResult ? results[results.Count - 1].Value : default(KAOSTools.Parsing.ParsedElement);
			cache = new CacheValue(state, value, hasResult);
			m_cache.Add(key, cache);
		}
		else
		{
			if (cache.HasResult)
				results.Add(new Result(this, start.Index, cache.State.Index - start.Index, m_input, cache.Value));
		}
		
		return cache.State;
	}
	
	private State DoChoice(State state, List<Result> results, params ParseMethod[] methods)
	{
		State start = state;
		int startResult = results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
				break;
			}
			else
			{
				state = new State(start.Index, false, ErrorSet.Combine(state.Errors, temp.Errors));
				results.RemoveRange(startResult, results.Count - startResult);
			}
		}
		
		return state;
	}
	
	private State DoSequence(State state, List<Result> results, params ParseMethod[] methods)
	{
		State start = state;
		int startResult = results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
			}
			else
			{
				state = new State(start.Index, false, ErrorSet.Combine(start.Errors, temp.Errors));
				results.RemoveRange(startResult, results.Count - startResult);
				break;
			}
		}
		
		return state;
	}
	
	private State DoRepetition(State state, List<Result> results, int min, int max, ParseMethod method)
	{
		State start = state;
		
		int count = 0;
		while (count <= max)
		{
			State temp = method(state, results);
			if (temp.Parsed && temp.Index > state.Index)
			{
				state = temp;
				++count;
			}
			else
			{
				state = new State(state.Index, true, ErrorSet.Combine(state.Errors, temp.Errors));
				break;
			}
		}
		
		if (count < min || count > max)
			state = new State(start.Index, false, ErrorSet.Combine(start.Errors, state.Errors));
		
		return state;
	}
	
	private State DoParseRange(State state, List<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
	{
		char ch = m_input[state.Index];
		
		bool matched = chars.IndexOf(ch) >= 0;
		for (int i = 0; i < ranges.Length && !matched; i += 2)
		{
			matched = ranges[i] <= ch && ch <= ranges[i + 1];
		}
		for (int i = 0; categories != null && i < categories.Length && !matched; ++i)
		{
			matched = char.GetUnicodeCategory(ch) == categories[i];
		}
		
		if (inverted)
			matched = !matched && ch != '\x0';
		
		if (matched)
		{
			results.Add(new Result(this, state.Index, 1, m_input, default(KAOSTools.Parsing.ParsedElement)));
			return new State(state.Index + 1, true, state.Errors);
		}
		
		return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, label)));
	}
	#endregion
	
	#region Private Types
	private struct CacheKey : IEquatable<CacheKey>
	{
		public CacheKey(string rule, int index)
		{
			m_rule = rule;
			m_index = index;
		}
		
		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			
			if (GetType() != obj.GetType())
				return false;
			
			CacheKey rhs = (CacheKey) obj;
			return this == rhs;
		}
		
		public bool Equals(CacheKey rhs)
		{
			return this == rhs;
		}
		
		public static bool operator==(CacheKey lhs, CacheKey rhs)
		{
			if (lhs.m_rule != rhs.m_rule)
				return false;
			
			if (lhs.m_index != rhs.m_index)
				return false;
			
			return true;
		}
		
		public static bool operator!=(CacheKey lhs, CacheKey rhs)
		{
			return !(lhs == rhs);
		}
		
		public override int GetHashCode()
		{
			int hash = 0;
			
			unchecked
			{
				hash += m_rule.GetHashCode();
				hash += m_index.GetHashCode();
			}
			
			return hash;
		}
		
		private string m_rule;
		private int m_index;
	}
	
	private struct CacheValue
	{
		public CacheValue(State state, KAOSTools.Parsing.ParsedElement value, bool hasResult)
		{
			State = state;
			Value = value;
			HasResult = hasResult;
		}
		
		public State State;
		
		public KAOSTools.Parsing.ParsedElement Value;
		
		public bool HasResult;
	}
	
	private delegate State ParseMethod(State state, List<Result> results);
	
	// These are either an error that caused parsing to fail or the reason a
	// successful parse stopped.
	private struct ErrorSet
	{
		public ErrorSet(int index, string expected)
		{
			Index = index;
			Expected = new string[]{expected};
		}
		
		public ErrorSet(int index, string[] expected)
		{
			Index = index;
			Expected = expected;
		}
		
		// The location associated with the errors. For a failed parse this will be the
		// same as State.Index. For a successful parse it will be State.Index or later.
		public int Index;
		
		// This will be the name of something which was expected, but not found.
		public string[] Expected;
		
		public static ErrorSet Combine(ErrorSet lhs, ErrorSet rhs)
		{
			if (lhs.Index > rhs.Index)
			{
				return lhs;
			}
			else if (lhs.Index < rhs.Index)
			{
				return rhs;
			}
			else
			{
				List<string> errors = new List<string>(lhs.Expected.Length + rhs.Expected.Length);
				errors.AddRange(lhs.Expected);
				foreach (string err in rhs.Expected)
				{
					if (errors.IndexOf(err) < 0)
						errors.Add(err);
				}
				return new ErrorSet(lhs.Index, errors.ToArray());
			}
		}
		
		public override string ToString()
		{
			if (Expected.Length > 0)
				return string.Format("Expected {0}", string.Join(" or ", Expected));
			else
				return "<none>";
		}
	}
	
	// The state of the parser.
	private struct State
	{
		public State(int index, bool parsed)
		{
			Index = index;
			Parsed = parsed;
			Errors = new ErrorSet(index, new string[0]);
		}
		
		public State(int index, bool parsed, ErrorSet errors)
		{
			Index = index;
			Parsed = parsed;
			Errors = errors;
		}
		
		// Index of the first unconsumed character.
		public int Index;
		
		// True if the expression associated with the state successfully parsed.
		public bool Parsed;
		
		// If Parsed is false then this will explain why. If Parsed is true it will
		// say why the parse stopped.
		public ErrorSet Errors;
	}
	
	// The result of parsing a literal or non-terminal.
	private struct Result
	{
		public Result(GoalModelParser parser, int index, int length, string input, KAOSTools.Parsing.ParsedElement value)
		{
			m_parser = parser;
			m_index = index;
			m_length = length;
			m_input = input;
			Value = value;
		}
		
		// The text which was parsed by the terminal or non-terminal.
		public string Text {get {return m_input.Substring(m_index, m_length);}}
		
		// The 1-based line number the (non)terminal started on.
		public int Line {get {return m_parser.DoGetLine(m_index);}}
		
		// The 1-based column number the (non)terminal started on.
		public int Col {get {return m_parser.DoGetCol(m_index);}}
		
		// For non-terminals this will be the result of the semantic action, 
		// otherwise it will be the default value.
		public KAOSTools.Parsing.ParsedElement Value;
		
		private GoalModelParser m_parser;
		private int m_index;
		private int m_length;
		private string m_input;
	}
	
	#endregion
	
	#region Fields
	private string m_input;
	private string m_file;
	private Dictionary<string, ParseMethod[]> m_nonterminals = new Dictionary<string, ParseMethod[]>();
	private Dictionary<CacheKey, CacheValue> m_cache = new Dictionary<CacheKey, CacheValue>();
	#endregion
}
