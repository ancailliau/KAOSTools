// Machine generated by peg-sharp 0.3.427.0 from GoalModelParser.peg.
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.Serialization;
using System.Security.Permissions;

namespace KAOSTools.Parsing
{
	[Serializable]
	public sealed class ParserException : Exception
	{
		public ParserException()
		{
		}
		
		public ParserException(string message) : base(message)
		{
		}
		
		public ParserException(int line, int col, string file, string message) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."))
		{
		}
		
		public ParserException(int line, int col, string file, string format, params object[] args) : this(line, col, file, string.Format(format, args))
		{
		}
		
		public ParserException(int line, int col, string file, string message, Exception inner) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."), inner)
		{
		}
		
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		private ParserException(SerializationInfo info, StreamingContext context) : base(info, context)
		{
		}
	}
	
	// Thread safe if Parser instances are not shared across threads.
	public sealed partial class GoalModelParser
	{
		public GoalModelParser()
		{
			m_nonterminals.Add("Start", new ParseMethod[]{this.DoParseStartRule});
			m_nonterminals.Add("Elements", new ParseMethod[]{this.DoParseElementsRule});
			m_nonterminals.Add("Import", new ParseMethod[]{this.DoParseImportRule});
			m_nonterminals.Add("Predicate", new ParseMethod[]{this.DoParsePredicateRule});
			m_nonterminals.Add("System", new ParseMethod[]{this.DoParseSystemRule});
			m_nonterminals.Add("Goal", new ParseMethod[]{this.DoParseGoalRule});
			m_nonterminals.Add("DomProp", new ParseMethod[]{this.DoParseDomPropRule});
			m_nonterminals.Add("Obstacle", new ParseMethod[]{this.DoParseObstacleRule});
			m_nonterminals.Add("Agent", new ParseMethod[]{this.DoParseAgentRule});
			m_nonterminals.Add("DomHyp", new ParseMethod[]{this.DoParseDomHypRule});
			m_nonterminals.Add("Entity", new ParseMethod[]{this.DoParseEntityRule});
			m_nonterminals.Add("Type", new ParseMethod[]{this.DoParseTypeRule});
			m_nonterminals.Add("Association", new ParseMethod[]{this.DoParseAssociationRule});
			m_nonterminals.Add("GoalAttribute", new ParseMethod[]{this.DoParseGoalAttributeRule});
			m_nonterminals.Add("DomPropAttribute", new ParseMethod[]{this.DoParseDomPropAttributeRule});
			m_nonterminals.Add("DomHypAttribute", new ParseMethod[]{this.DoParseDomHypAttributeRule});
			m_nonterminals.Add("ObstacleAttribute", new ParseMethod[]{this.DoParseObstacleAttributeRule});
			m_nonterminals.Add("AgentAttribute", new ParseMethod[]{this.DoParseAgentAttributeRule});
			m_nonterminals.Add("PredicateAttribute", new ParseMethod[]{this.DoParsePredicateAttributeRule});
			m_nonterminals.Add("SystemAttribute", new ParseMethod[]{this.DoParseSystemAttributeRule});
			m_nonterminals.Add("EntityAttribute", new ParseMethod[]{this.DoParseEntityAttributeRule});
			m_nonterminals.Add("TypeAttribute", new ParseMethod[]{this.DoParseTypeAttributeRule});
			m_nonterminals.Add("AssociationAttribute", new ParseMethod[]{this.DoParseAssociationAttributeRule});
			m_nonterminals.Add("IdAttribute", new ParseMethod[]{this.DoParseIdAttributeRule});
			m_nonterminals.Add("NameAttribute", new ParseMethod[]{this.DoParseNameAttributeRule});
			m_nonterminals.Add("FormalSpecAttribute", new ParseMethod[]{this.DoParseFormalSpecAttributeRule});
			m_nonterminals.Add("DefinitionAttribute", new ParseMethod[]{this.DoParseDefinitionAttributeRule});
			m_nonterminals.Add("RDSAttribute", new ParseMethod[]{this.DoParseRDSAttributeRule});
			m_nonterminals.Add("Probability", new ParseMethod[]{this.DoParseProbabilityRule});
			m_nonterminals.Add("ObstructedBy", new ParseMethod[]{this.DoParseObstructedByRule});
			m_nonterminals.Add("AssumptionAttribute", new ParseMethod[]{this.DoParseAssumptionAttributeRule});
			m_nonterminals.Add("ExceptionAttribute", new ParseMethod[]{this.DoParseExceptionAttributeRule});
			m_nonterminals.Add("ResolvedBy", new ParseMethod[]{this.DoParseResolvedByRule});
			m_nonterminals.Add("AlternativeAttribute", new ParseMethod[]{this.DoParseAlternativeAttributeRule});
			m_nonterminals.Add("IsA", new ParseMethod[]{this.DoParseIsARule});
			m_nonterminals.Add("AgentTypeAttribute", new ParseMethod[]{this.DoParseAgentTypeAttributeRule});
			m_nonterminals.Add("EntityTypeAttribute", new ParseMethod[]{this.DoParseEntityTypeAttributeRule});
			m_nonterminals.Add("RefinedByObstacle", new ParseMethod[]{this.DoParseRefinedByObstacleRule});
			m_nonterminals.Add("RefinedByGoal", new ParseMethod[]{this.DoParseRefinedByGoalRule});
			m_nonterminals.Add("RefinedByPattern", new ParseMethod[]{this.DoParseRefinedByPatternRule});
			m_nonterminals.Add("RefinedByAlternative", new ParseMethod[]{this.DoParseRefinedByAlternativeRule});
			m_nonterminals.Add("AssignedTo", new ParseMethod[]{this.DoParseAssignedToRule});
			m_nonterminals.Add("Attribute", new ParseMethod[]{this.DoParseAttributeRule});
			m_nonterminals.Add("Argument", new ParseMethod[]{this.DoParseArgumentRule});
			m_nonterminals.Add("Link", new ParseMethod[]{this.DoParseLinkRule});
			m_nonterminals.Add("ResolutionPattern", new ParseMethod[]{this.DoParseResolutionPatternRule});
			m_nonterminals.Add("RefinementPattern", new ParseMethod[]{this.DoParseRefinementPatternRule});
			m_nonterminals.Add("Multiplicity", new ParseMethod[]{this.DoParseMultiplicityRule});
			m_nonterminals.Add("MultiplicityLowerBound", new ParseMethod[]{this.DoParseMultiplicityLowerBoundRule});
			m_nonterminals.Add("MultiplicityUpperBound", new ParseMethod[]{this.DoParseMultiplicityUpperBoundRule});
			m_nonterminals.Add("Identifier", new ParseMethod[]{this.DoParseIdentifierRule});
			m_nonterminals.Add("Name", new ParseMethod[]{this.DoParseNameRule});
			m_nonterminals.Add("String", new ParseMethod[]{this.DoParseStringRule});
			m_nonterminals.Add("Float", new ParseMethod[]{this.DoParseFloatRule});
			m_nonterminals.Add("Formula", new ParseMethod[]{this.DoParseFormulaRule});
			m_nonterminals.Add("StrongBinary", new ParseMethod[]{this.DoParseStrongBinaryRule});
			m_nonterminals.Add("Binary", new ParseMethod[]{this.DoParseBinaryRule});
			m_nonterminals.Add("TemporalBinary", new ParseMethod[]{this.DoParseTemporalBinaryRule});
			m_nonterminals.Add("And", new ParseMethod[]{this.DoParseAndRule});
			m_nonterminals.Add("Or", new ParseMethod[]{this.DoParseOrRule});
			m_nonterminals.Add("Unary", new ParseMethod[]{this.DoParseUnaryRule});
			m_nonterminals.Add("Atom", new ParseMethod[]{this.DoParseAtomRule});
			m_nonterminals.Add("Comparison", new ParseMethod[]{this.DoParseComparisonRule});
			m_nonterminals.Add("Comparator", new ParseMethod[]{this.DoParseComparatorRule});
			m_nonterminals.Add("ComparisonMember", new ParseMethod[]{this.DoParseComparisonMemberRule});
			m_nonterminals.Add("AttributeReference", new ParseMethod[]{this.DoParseAttributeReferenceRule});
			m_nonterminals.Add("RelationReference", new ParseMethod[]{this.DoParseRelationReferenceRule});
			m_nonterminals.Add("PredicateReference", new ParseMethod[]{this.DoParsePredicateReferenceRule});
			m_nonterminals.Add("VariableReference", new ParseMethod[]{this.DoParseVariableReferenceRule});
			m_nonterminals.Add("EventuallyTimeBoundEmphasis", new ParseMethod[]{this.DoParseEventuallyTimeBoundEmphasisRule});
			m_nonterminals.Add("GloballyTimeBoundEmphasis", new ParseMethod[]{this.DoParseGloballyTimeBoundEmphasisRule});
			m_nonterminals.Add("EventuallyTimeBound", new ParseMethod[]{this.DoParseEventuallyTimeBoundRule});
			m_nonterminals.Add("GloballyTimeBound", new ParseMethod[]{this.DoParseGloballyTimeBoundRule});
			m_nonterminals.Add("TimeConstraint", new ParseMethod[]{this.DoParseTimeConstraintRule});
			m_nonterminals.Add("TimeUnit", new ParseMethod[]{this.DoParseTimeUnitRule});
			m_nonterminals.Add("Integer", new ParseMethod[]{this.DoParseIntegerRule});
			m_nonterminals.Add("Number", new ParseMethod[]{this.DoParseNumberRule});
			m_nonterminals.Add("Variable", new ParseMethod[]{this.DoParseVariableRule});
			m_nonterminals.Add("Bool", new ParseMethod[]{this.DoParseBoolRule});
			m_nonterminals.Add("S", new ParseMethod[]{this.DoParseSRule});
			m_nonterminals.Add("Space", new ParseMethod[]{this.DoParseSpaceRule});
			m_nonterminals.Add("Comment", new ParseMethod[]{this.DoParseCommentRule});
			OnCtorEpilog();
		}
		
		public KAOSTools.Parsing.ParsedElement Parse(string input)
		{
			return DoParseFile(input, null);
		}
		
		// File is used for error reporting.
		public KAOSTools.Parsing.ParsedElement Parse(string input, string file)
		{
			return DoParseFile(input, file);
		}
		
		#region Non-Terminal Parse Methods
		// Start := S Elements S
		private State DoParseStartRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Elements");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Elements := ((System / Predicate / Goal / DomProp / Obstacle / Agent / Import / DomHyp / Entity / Type / Association) S)*
		private State DoParseElementsRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoRepetition(_state, results, 0, 2147483647,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "System");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Predicate");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Goal");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "DomProp");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Obstacle");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Agent");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Import");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "DomHyp");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Entity");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Type");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Association");});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildElements (results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Import := 'import' S '"' String '"'
		private State DoParseImportRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "import");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "String");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = Import(results[2].Text);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Predicate := ('declare' / 'override') S 'predicate' S (PredicateAttribute S)* 'end'
		private State DoParsePredicateRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "predicate");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "PredicateAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildPredicate(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// System := ('declare' / 'override') S 'system' S (SystemAttribute S)* 'end'
		private State DoParseSystemRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "system");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "SystemAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildSystem(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Goal := ('declare' / 'override') S 'goal' S (GoalAttribute S)* 'end'
		private State DoParseGoalRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "goal");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "GoalAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildGoal(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// DomProp := ('declare' / 'override') S ('domainproperty' / 'domprop') S (DomPropAttribute S)* 'end'
		private State DoParseDomPropRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "domainproperty");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "domprop");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "DomPropAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildDomainProperty(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Obstacle := ('declare' / 'override') S 'obstacle' S (ObstacleAttribute S)* 'end'
		private State DoParseObstacleRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "obstacle");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ObstacleAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildObstacle(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Agent := ('declare' / 'override') S 'agent' S (AgentAttribute S)* 'end'
		private State DoParseAgentRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "agent");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "AgentAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAgent(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// DomHyp := ('declare' / 'override') S ('domainhypothesis' / 'domhyp') S (DomHypAttribute S)* 'end'
		private State DoParseDomHypRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "domainhypothesis");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "domhyp");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "DomHypAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildDomainHypothesis(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Entity := ('declare' / 'override') S ('entity' / 'object') S (EntityAttribute S)* 'end'
		private State DoParseEntityRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "entity");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "object");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "EntityAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildEntity(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Type := ('declare' / 'override') S 'type' S (TypeAttribute S)* 'end'
		private State DoParseTypeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "TypeAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildType(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Association := ('declare' / 'override') S ('association' / 'relation') S (AssociationAttribute S)* 'end'
		private State DoParseAssociationRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "declare");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "override");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "association");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "relation");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "AssociationAttribute");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "end");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAssociation(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// GoalAttribute := IdAttribute / NameAttribute / DefinitionAttribute / FormalSpecAttribute / RefinedByGoal / ObstructedBy / AssignedTo / RDSAttribute / ExceptionAttribute / AssumptionAttribute
		private State DoParseGoalAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "FormalSpecAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RefinedByGoal");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ObstructedBy");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "AssignedTo");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RDSAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ExceptionAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "AssumptionAttribute");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// DomPropAttribute := IdAttribute / NameAttribute / DefinitionAttribute / FormalSpecAttribute / Probability
		private State DoParseDomPropAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "FormalSpecAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Probability");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// DomHypAttribute := IdAttribute / NameAttribute / DefinitionAttribute
		private State DoParseDomHypAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// ObstacleAttribute := IdAttribute / NameAttribute / DefinitionAttribute / FormalSpecAttribute / RefinedByObstacle / ResolvedBy / Probability
		private State DoParseObstacleAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "FormalSpecAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RefinedByObstacle");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ResolvedBy");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Probability");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// AgentAttribute := IdAttribute / NameAttribute / DefinitionAttribute / AgentTypeAttribute
		private State DoParseAgentAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "AgentTypeAttribute");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// PredicateAttribute := IdAttribute / NameAttribute / DefinitionAttribute / Argument / FormalSpecAttribute
		private State DoParsePredicateAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Argument");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "FormalSpecAttribute");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// SystemAttribute := IdAttribute / NameAttribute / DefinitionAttribute / AlternativeAttribute
		private State DoParseSystemAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "AlternativeAttribute");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// EntityAttribute := IdAttribute / NameAttribute / DefinitionAttribute / Attribute / IsA / EntityTypeAttribute
		private State DoParseEntityAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Attribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IsA");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "EntityTypeAttribute");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// TypeAttribute := IdAttribute / NameAttribute / DefinitionAttribute
		private State DoParseTypeAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// AssociationAttribute := IdAttribute / NameAttribute / DefinitionAttribute / Attribute / Link
		private State DoParseAssociationAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NameAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "DefinitionAttribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Attribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Link");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// IdAttribute := 'id' S Identifier
		private State DoParseIdAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "id");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildIdentifierAttribute(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// NameAttribute := 'name' S '"' String? '"'
		private State DoParseNameAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "name");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "String");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildNameAttribute(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// FormalSpecAttribute := 'formalspec' S Formula
		private State DoParseFormalSpecAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "formalspec");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Formula");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildFormalSpecAttribute(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// DefinitionAttribute := 'definition' S '"' String? '"'
		private State DoParseDefinitionAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "definition");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "String");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildDefinitionAttribute(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RDSAttribute := 'rds' S Float
		private State DoParseRDSAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "rds");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Float");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildRDS(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Probability := ('probability' / 'eps') S Float
		private State DoParseProbabilityRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "probability");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "eps");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Float");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildProbability(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// ObstructedBy := 'obstructedby' S (Obstacle / Name / Identifier)
		private State DoParseObstructedByRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "obstructedby");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Obstacle");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildObstructedBy(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// AssumptionAttribute := 'assumption' S (('not' (Obstacle / Name / Identifier)) / (DomHyp / Goal / Name / Identifier))
		private State DoParseAssumptionAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "assumption");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "not");},
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Obstacle");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Name");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});},
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "DomHyp");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Goal");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Name");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Identifier");});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAssumptionAttribute(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// ExceptionAttribute := 'exception' S (Obstacle / Name / Identifier) (S 'then' S (Goal / Name / Identifier))?
		private State DoParseExceptionAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "exception");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Obstacle");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "then");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Goal");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Name");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildExceptionAttribute(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// ResolvedBy := 'resolvedby' (S '(' S ResolutionPattern S ')')? S (Goal / Name / Identifier)
		private State DoParseResolvedByRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "resolvedby");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "(");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ResolutionPattern");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ")");});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Goal");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildResolvedBy(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// AlternativeAttribute := 'alternative' S (System / Name / Identifier)
		private State DoParseAlternativeAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "alternative");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "System");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAlternativeAttribute(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// IsA := 'is' S (Entity / Name / Identifier)
		private State DoParseIsARule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "is");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Entity");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildIsA(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// AgentTypeAttribute := 'type' S ('software' / 'environment')
		private State DoParseAgentTypeAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "software");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "environment");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAgentTypeAttribute (results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// EntityTypeAttribute := 'type' S ('software' / 'environment' / 'shared')
		private State DoParseEntityTypeAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "type");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "software");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "environment");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "shared");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildEntityTypeAttribute (results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RefinedByObstacle := 'refinedby' S (Obstacle / DomProp / DomHyp / Name / Identifier) (S ',' S (Obstacle / DomProp / DomHyp / Name / Identifier))*
		private State DoParseRefinedByObstacleRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "refinedby");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Obstacle");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "DomProp");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "DomHyp");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Obstacle");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "DomProp");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "DomHyp");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Name");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildRefinedBy(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RefinedByGoal := 'refinedby' S (RefinedByPattern S)? (RefinedByAlternative S)? (Goal / DomProp / DomHyp / Name / Identifier) (S ',' S (Goal / DomProp / DomHyp / Name / Identifier))*
		private State DoParseRefinedByGoalRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "refinedby");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "RefinedByPattern");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "RefinedByAlternative");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Goal");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "DomProp");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "DomHyp");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Goal");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "DomProp");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "DomHyp");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Name");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildRefinedBy(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RefinedByPattern := '(' S RefinementPattern S ')'
		private State DoParseRefinedByPatternRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RefinementPattern");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildRefinedByPattern(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RefinedByAlternative := '[' S (Name / Identifier) S ']'
		private State DoParseRefinedByAlternativeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "[");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "]");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildRefinedByAlternative(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// AssignedTo := 'assignedto' ('[' S (Name / Identifier) S ']')? S (Agent / Name / Identifier) (S ',' S (Agent / Name / Identifier))*
		private State DoParseAssignedToRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "assignedto");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "[");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Name");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "]");});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Agent");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Agent");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Name");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAssignedTo(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Attribute := 'attribute' S Name S (':' S (Type / Name / Identifier))?
		private State DoParseAttributeRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "attribute");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Name");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ":");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Type");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Name");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAttribute(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Argument := 'argument' S Identifier S (':' S (Entity / Name / Identifier))?
		private State DoParseArgumentRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "argument");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ":");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Entity");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Name");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildArgument(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Link := 'link' S Multiplicity? S (Entity / Name / Identifier)
		private State DoParseLinkRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "link");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Multiplicity");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Entity");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildLink(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// ResolutionPattern := ('substitution' / 'prevention' / 'obstacle_reduction' / 'restoration' / 'weakening' / 'weak_mitigation' / 'strong_mitigation') (S '[' S (DomHyp / Goal / Name / Identifier) (S ',' S (DomHyp / Goal / Name / Identifier))* S ']')?
		private State DoParseResolutionPatternRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "substitution");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "prevention");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "obstacle_reduction");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "restoration");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "weakening");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "weak_mitigation");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "strong_mitigation");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "[");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoChoice(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "DomHyp");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Goal");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Name");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Identifier");});},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 2147483647,
						delegate (State s4, List<Result> r4) {return DoSequence(s4, r4,
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "S");},
							delegate (State s5, List<Result> r5) {return DoParseLiteral(s5, r5, ",");},
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "S");},
							delegate (State s5, List<Result> r5) {return DoChoice(s5, r5,
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "DomHyp");},
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "Goal");},
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "Name");},
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "Identifier");});});});},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "]");});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildResolutionPattern(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RefinementPattern := 'milestone' / ('case' S '[' S Float S ']') / 'introduce_guard' / 'divide_and_conquer' / 'unmonitorability' / 'uncontrollability'
		private State DoParseRefinementPatternRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "milestone");},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "case");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "[");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Float");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "introduce_guard");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "divide_and_conquer");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "unmonitorability");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "uncontrollability");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildRefinementPattern(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Multiplicity := '(' S MultiplicityLowerBound S ('..' S MultiplicityUpperBound S)? ')'
		private State DoParseMultiplicityRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "MultiplicityLowerBound");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "..");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "MultiplicityUpperBound");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildMultiplicity(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// MultiplicityLowerBound := [0-9] / 'M' / 'N'
		private State DoParseMultiplicityLowerBoundRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, string.Empty, "09", null, "[0-9]");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "M");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "N");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// MultiplicityUpperBound := [0-9] / 'M' / 'N' / '*'
		private State DoParseMultiplicityUpperBoundRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, string.Empty, "09", null, "[0-9]");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "M");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "N");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "*");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[0].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Identifier := [a-zA-Z] [_-a-zA-Z0-9]*
		private State DoParseIdentifierRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, string.Empty, "azAZ", null, "[a-zA-Z]");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, "_-", "azAZ09", null, "[_-a-zA-Z0-9]");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildIdentifier(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Name := '"' String '"'
		private State DoParseNameRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "String");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildName(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// String := ('""' / [^\"])+
		private State DoParseStringRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoRepetition(_state, results, 1, 2147483647,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "\"\"");},
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "\"", string.Empty, null, "[^\"]");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildString(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "string";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Float := ('.' [0-9]+) / ([0-9]+ ('.' [0-9]+)?)
		private State DoParseFloatRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ".");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 1, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, string.Empty, "09", null, "[0-9]");});});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 1, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, string.Empty, "09", null, "[0-9]");});},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ".");},
						delegate (State s4, List<Result> r4) {return DoRepetition(s4, r4, 1, 2147483647,
							delegate (State s5, List<Result> r5) {return DoParseRange(s5, r5, false, string.Empty, "09", null, "[0-9]");});});});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildFloat(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "float";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Formula := ('forall' S Variable S ':' S (Identifier / Name) (',' S Variable S ':' S (Identifier / Name))* S '.' S Formula) / ('exists' S Variable S ':' S (Identifier / Name) (',' S Variable S ':' S (Identifier / Name))* S '.' S Formula) / StrongBinary
		private State DoParseFormulaRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "forall");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Variable");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ":");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Identifier");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Name");});},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 2147483647,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ",");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Variable");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ":");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoChoice(s4, r4,
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "Identifier");},
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "Name");});});});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ".");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "exists");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Variable");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ":");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Identifier");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Name");});},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 2147483647,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ",");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Variable");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ":");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoChoice(s4, r4,
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "Identifier");},
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "Name");});});});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ".");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "StrongBinary");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildFormula(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "temporal formula";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// StrongBinary := ('when' S Binary S 'then' S Formula) / Binary
		private State DoParseStrongBinaryRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "when");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Binary");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "then");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Binary");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildStrongBinary(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "temporal implication";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Binary := ('if' S TemporalBinary S 'then' S Formula) / (TemporalBinary S 'iff' S Formula) / TemporalBinary
		private State DoParseBinaryRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "if");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TemporalBinary");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "then");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TemporalBinary");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "iff");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "TemporalBinary");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildBinary(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "binary formula";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// TemporalBinary := (And S 'until' S Formula) / (And S 'release' S Formula) / (And S 'unless' S Formula) / And
		private State DoParseTemporalBinaryRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "And");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "until");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "And");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "release");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "And");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "unless");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "And");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildTemporalBinary(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "temporal binary formula";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// And := (Or S 'and' S Formula) / Or
		private State DoParseAndRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Or");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "and");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Or");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAnd(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "and";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Or := (Unary S 'or' S Formula) / Unary
		private State DoParseOrRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Unary");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "or");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Unary");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildOr(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "or";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Unary := ('not' S Formula) / ('next' S Formula) / (('sooner-or-later' / 'eventually') (S EventuallyTimeBoundEmphasis)? S Formula (S 'before' S Formula)?) / (('always' / 'globally') (S GloballyTimeBoundEmphasis)? S Formula) / Atom
		private State DoParseUnaryRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "not");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "next");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "sooner-or-later");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "eventually");});},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "EventuallyTimeBoundEmphasis");});});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "before");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Formula");});});});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "always");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "globally");});},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "GloballyTimeBoundEmphasis");});});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Atom");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildUnary(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "unary formula";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Atom := RelationReference / Comparison / AttributeReference / PredicateReference / ('(' S Formula S ')')
		private State DoParseAtomRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "RelationReference");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Comparison");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "AttributeReference");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "PredicateReference");},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "(");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Formula");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ")");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAtom(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "atomic formula";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Comparison := ComparisonMember S Comparator S ComparisonMember
		private State DoParseComparisonRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "ComparisonMember");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Comparator");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "ComparisonMember");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildComparison(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "comparison";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Comparator := '==' / '!=' / '>=' / '<=' / '>' / '<'
		private State DoParseComparatorRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "==");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "!=");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ">=");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "<=");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ">");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "<");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = null;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "comparator";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// ComparisonMember := AttributeReference / PredicateReference / VariableReference / ('"' String? '"') / Number / Bool
		private State DoParseComparisonMemberRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "AttributeReference");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "PredicateReference");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "VariableReference");},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "\"");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "String");});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "\"");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Number");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Bool");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildComparisonMember(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "comparison member";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// AttributeReference := Variable '.' (Identifier / Name)
		private State DoParseAttributeReferenceRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Variable");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ".");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildAttributeReference(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "attribute reference";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// RelationReference := '(' S Variable (S ',' S Variable)* S ')' S 'in' S (Identifier / Name)
		private State DoParseRelationReferenceRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Variable");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ",");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Variable");});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "in");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildRelationReference(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "relation reference";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// PredicateReference := (Identifier (S '(' S (Variable (S ',' S Variable)*)? S ')')) / (Name S '(' S (Variable (S ',' S Variable)*)? S ')')
		private State DoParsePredicateReferenceRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Identifier");},
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "(");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoSequence(s4, r4,
							delegate (State s5, List<Result> r5) {return DoParse(s5, r5, "Variable");},
							delegate (State s5, List<Result> r5) {return DoRepetition(s5, r5, 0, 2147483647,
								delegate (State s6, List<Result> r6) {return DoSequence(s6, r6,
									delegate (State s7, List<Result> r7) {return DoParse(s7, r7, "S");},
									delegate (State s7, List<Result> r7) {return DoParseLiteral(s7, r7, ",");},
									delegate (State s7, List<Result> r7) {return DoParse(s7, r7, "S");},
									delegate (State s7, List<Result> r7) {return DoParse(s7, r7, "Variable");});});});});},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ")");});});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Name");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "(");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Variable");},
						delegate (State s4, List<Result> r4) {return DoRepetition(s4, r4, 0, 2147483647,
							delegate (State s5, List<Result> r5) {return DoSequence(s5, r5,
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "S");},
								delegate (State s6, List<Result> r6) {return DoParseLiteral(s6, r6, ",");},
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "S");},
								delegate (State s6, List<Result> r6) {return DoParse(s6, r6, "Variable");});});});});},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ")");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildPredicateReference(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "predicate reference";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// VariableReference := Variable
		private State DoParseVariableReferenceRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParse(_state, results, "Variable");
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildVariable(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "number";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// EventuallyTimeBoundEmphasis := ',' S EventuallyTimeBound S ','
		private State DoParseEventuallyTimeBoundEmphasisRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ",");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "EventuallyTimeBound");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ",");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[1].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "time bound emphasis";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// GloballyTimeBoundEmphasis := ',' S GloballyTimeBound S ','
		private State DoParseGloballyTimeBoundEmphasisRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ",");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "GloballyTimeBound");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ",");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = results[1].Value;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "time bound emphasis";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// EventuallyTimeBound := (('strictly' S)? 'before' S TimeConstraint) / (('strictly' S)? 'after' S TimeConstraint) / ('in' S TimeConstraint)
		private State DoParseEventuallyTimeBoundRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "strictly");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");});});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "before");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TimeConstraint");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "strictly");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");});});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "after");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TimeConstraint");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "in");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TimeConstraint");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildEventuallyTimeBound(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "time bound";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// GloballyTimeBound := ('for' S ('strictly' S)? 'more' S 'than' S TimeConstraint) / ('for' S ('strictly' S)? 'less' S 'than' S TimeConstraint) / ('for' S TimeConstraint)
		private State DoParseGloballyTimeBoundRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "for");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "strictly");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");});});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "more");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "than");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TimeConstraint");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "for");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "strictly");},
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "S");});});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "less");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "than");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TimeConstraint");});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "for");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TimeConstraint");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildGloballyTimeBound(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "time bound";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// TimeConstraint := (Integer S TimeUnit) (S Integer S TimeUnit)*
		private State DoParseTimeConstraintRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Integer");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "S");},
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "TimeUnit");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Integer");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "TimeUnit");});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = BuildTimeConstraint(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "time";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// TimeUnit := (('day' 's'?) / 'd') / (('hour' 's'?) / 'h') / (('minute' 's'?) / 'min') / (('second' 's'?) / 's') / (('milisecond' 's'?) / 'ms')
		private State DoParseTimeUnitRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "day");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "s");});});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "d");});},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "hour");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "s");});});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "h");});},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "minute");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "s");});});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "min");});},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "second");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "s");});});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "s");});},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "milisecond");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, "s");});});},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "ms");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = null;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "time unit";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Integer := [0-9]+
		private State DoParseIntegerRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoRepetition(_state, results, 1, 2147483647,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, string.Empty, "09", null, "[0-9]");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = null;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "integer";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Number := ('.' [0-9]+) / ([0-9]+ ('.' [0-9]+)?)
		private State DoParseNumberRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ".");},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 1, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, string.Empty, "09", null, "[0-9]");});});},
			delegate (State s, List<Result> r) {return DoSequence(s, r,
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 1, 2147483647,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, string.Empty, "09", null, "[0-9]");});},
				delegate (State s2, List<Result> r2) {return DoRepetition(s2, r2, 0, 1,
					delegate (State s3, List<Result> r3) {return DoSequence(s3, r3,
						delegate (State s4, List<Result> r4) {return DoParseLiteral(s4, r4, ".");},
						delegate (State s4, List<Result> r4) {return DoRepetition(s4, r4, 1, 2147483647,
							delegate (State s5, List<Result> r5) {return DoParseRange(s5, r5, false, string.Empty, "09", null, "[0-9]");});});});});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = null;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "number";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Variable := [a-z]+ [a-zA-Z0-9]*
		private State DoParseVariableRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "az", null, "[a-z]");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "azAZ09", null, "[a-zA-Z0-9]");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = null;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "number";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Bool := 'true' / 'false'
		private State DoParseBoolRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "true");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "false");});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				value = null;
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "bool";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// S := (Space* Comment+ Space*)+ / Space*
		private State DoParseSRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 2147483647,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Space");});},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 1, 2147483647,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Comment");});},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 2147483647,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Space");});});});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Space");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				text = null;
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Space := [ \t\r\n]
		private State DoParseSpaceRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, " \t\r\n", string.Empty, null, "[ \t\r\n]");
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "whitespace";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// Comment := '#' [^\r\n]*
		private State DoParseCommentRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "#");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "\r\n", string.Empty, null, "[^\r\n]");});});
			
			if (_state.Parsed)
			{
				KAOSTools.Parsing.ParsedElement value = results.Count > 0 ? results[0].Value : default(KAOSTools.Parsing.ParsedElement);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				text = null;
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "comment";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		#endregion
		
		#region Private Helper Methods
		partial void OnCtorEpilog();
		partial void OnParseProlog();
		partial void OnParseEpilog(State state);
		
		private KAOSTools.Parsing.ParsedElement DoParseFile(string input, string file)
		{
			m_file = file;
			m_input = m_file;				// we need to ensure that m_file is used or we will (in some cases) get a compiler warning
			m_input = input + "\x0";	// add a sentinel so we can avoid range checks
			m_cache.Clear();
			
			State state = new State(0, true);
			List<Result> results = new List<Result>();
			
			OnParseProlog();
			state = DoParse(state, results, "Start");
			
			int i = state.Index;
			if (!state.Parsed)
				DoThrow(state.Errors.Index, state.Errors.ToString());
			else if (i < input.Length)
				if (state.Errors.Expected.Length > 0)
					DoThrow(state.Errors.Index, state.Errors.ToString());
				else
					DoThrow(state.Errors.Index, "Not all input was consumed starting from '" + input.Substring(i, Math.Min(16, input.Length - i)) + "'");
			OnParseEpilog(state);
			
			return results[0].Value;
		}
		
		public string DoEscapeAll(string s)
		{
			System.Text.StringBuilder builder = new System.Text.StringBuilder(s.Length);
			
			foreach (char ch in s)
			{
				if (ch == '\n')
					builder.Append("\\n");
				
				else if (ch == '\r')
					builder.Append("\\r");
				
				else if (ch == '\t')
					builder.Append("\\t");
				
				else if (ch < ' ')
					builder.AppendFormat("\\x{0:X2}", (int) ch);
				
				else
					builder.Append(ch);
			}
			
			return builder.ToString();
		}
		
		// This is normally only used for error handling so it doesn't need to be too
		// fast. If it somehow does become a bottleneck for some parsers they can
		// replace it with the custom-methods setting.
		private int DoGetLine(int index)
		{
			int line = 1;
			
			int i = 0;
			while (i <= index)
			{
				char ch = m_input[i++];
				
				if (ch == '\r' && m_input[i] == '\n')
				{
					++i;
					++line;
				}
				else if (ch == '\r')
				{
					++line;
				}
				else if (ch == '\n')
				{
					++line;
				}
			}
			
			return line;
		}
		
		private int DoGetCol(int index)
		{
			int start = index;
			
			while (index > 0 && m_input[index - 1] != '\n' && m_input[index - 1] != '\r')
			{
				--index;
			}
			
			return start - index + 1;
		}
		
		private void DoThrow(int index, string format, params object[] args)
		{
			int line = DoGetLine(index);
			int col = DoGetCol(index);
		
			// We need this retarded if or string.Format will throw an error if it
			// gets a format string like "Expected { or something".
			if (args != null && args.Length > 0)
				throw new ParserException(line, col, m_file, DoEscapeAll(string.Format(format, args)));
			else
				throw new ParserException(line, col, m_file, DoEscapeAll(format));
		}
		
		private State DoParseLiteral(State state, List<Result> results, string literal)
		{
			int j = state.Index;
			
			for (int i = 0; i < literal.Length; ++i)
			{
				if (m_input[j + i] != literal[i])
				{
					return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, literal)));
				}
			}
			
			int k = j + literal.Length;
			
			results.Add(new Result(this, j, literal.Length, m_input, default(KAOSTools.Parsing.ParsedElement)));
			state = new State(k, true, state.Errors);
			
			return state;
		}
		
		private State DoParse(State state, List<Result> results, string nonterminal)
		{
			State start = state;
			
			CacheValue cache;
			CacheKey key = new CacheKey(nonterminal, start.Index);
			if (!m_cache.TryGetValue(key, out cache))
			{
				ParseMethod[] methods = m_nonterminals[nonterminal];
				
				int oldCount = results.Count;
				state = DoChoice(state, results, methods);
				
				bool hasResult = state.Parsed && results.Count > oldCount;
				KAOSTools.Parsing.ParsedElement value = hasResult ? results[results.Count - 1].Value : default(KAOSTools.Parsing.ParsedElement);
				cache = new CacheValue(state, value, hasResult);
				m_cache.Add(key, cache);
			}
			else
			{
				if (cache.HasResult)
					results.Add(new Result(this, start.Index, cache.State.Index - start.Index, m_input, cache.Value));
			}
			
			return cache.State;
		}
		
		private State DoChoice(State state, List<Result> results, params ParseMethod[] methods)
		{
			State start = state;
			int startResult = results.Count;
			
			foreach (ParseMethod method in methods)
			{
				State temp = method(state, results);
				if (temp.Parsed)
				{
					state = temp;
					break;
				}
				else
				{
					state = new State(start.Index, false, ErrorSet.Combine(state.Errors, temp.Errors));
					results.RemoveRange(startResult, results.Count - startResult);
				}
			}
			
			return state;
		}
		
		private State DoSequence(State state, List<Result> results, params ParseMethod[] methods)
		{
			State start = state;
			int startResult = results.Count;
			
			foreach (ParseMethod method in methods)
			{
				State temp = method(state, results);
				if (temp.Parsed)
				{
					state = temp;
				}
				else
				{
					state = new State(start.Index, false, ErrorSet.Combine(start.Errors, temp.Errors));
					results.RemoveRange(startResult, results.Count - startResult);
					break;
				}
			}
			
			return state;
		}
		
		private State DoRepetition(State state, List<Result> results, int min, int max, ParseMethod method)
		{
			State start = state;
			
			int count = 0;
			while (count <= max)
			{
				State temp = method(state, results);
				if (temp.Parsed && temp.Index > state.Index)
				{
					state = temp;
					++count;
				}
				else
				{
					state = new State(state.Index, true, ErrorSet.Combine(state.Errors, temp.Errors));
					break;
				}
			}
			
			if (count < min || count > max)
				state = new State(start.Index, false, ErrorSet.Combine(start.Errors, state.Errors));
			
			return state;
		}
		
		private State DoParseRange(State state, List<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
		{
			char ch = m_input[state.Index];
			
			bool matched = chars.IndexOf(ch) >= 0;
			for (int i = 0; i < ranges.Length && !matched; i += 2)
			{
				matched = ranges[i] <= ch && ch <= ranges[i + 1];
			}
			for (int i = 0; categories != null && i < categories.Length && !matched; ++i)
			{
				matched = char.GetUnicodeCategory(ch) == categories[i];
			}
			
			if (inverted)
				matched = !matched && ch != '\x0';
			
			if (matched)
			{
				results.Add(new Result(this, state.Index, 1, m_input, default(KAOSTools.Parsing.ParsedElement)));
				return new State(state.Index + 1, true, state.Errors);
			}
			
			return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, label)));
		}
		#endregion
		
		#region Private Types
		private struct CacheKey : IEquatable<CacheKey>
		{
			public CacheKey(string rule, int index)
			{
				m_rule = rule;
				m_index = index;
			}
			
			public override bool Equals(object obj)
			{
				if (obj == null)
					return false;
				
				if (GetType() != obj.GetType())
					return false;
				
				CacheKey rhs = (CacheKey) obj;
				return this == rhs;
			}
			
			public bool Equals(CacheKey rhs)
			{
				return this == rhs;
			}
			
			public static bool operator==(CacheKey lhs, CacheKey rhs)
			{
				if (lhs.m_rule != rhs.m_rule)
					return false;
				
				if (lhs.m_index != rhs.m_index)
					return false;
				
				return true;
			}
			
			public static bool operator!=(CacheKey lhs, CacheKey rhs)
			{
				return !(lhs == rhs);
			}
			
			public override int GetHashCode()
			{
				int hash = 0;
				
				unchecked
				{
					hash += m_rule.GetHashCode();
					hash += m_index.GetHashCode();
				}
				
				return hash;
			}
			
			private string m_rule;
			private int m_index;
		}
		
		private struct CacheValue
		{
			public CacheValue(State state, KAOSTools.Parsing.ParsedElement value, bool hasResult)
			{
				State = state;
				Value = value;
				HasResult = hasResult;
			}
			
			public State State;
			
			public KAOSTools.Parsing.ParsedElement Value;
			
			public bool HasResult;
		}
		
		private delegate State ParseMethod(State state, List<Result> results);
		
		// These are either an error that caused parsing to fail or the reason a
		// successful parse stopped.
		private struct ErrorSet
		{
			public ErrorSet(int index, string expected)
			{
				Index = index;
				Expected = new string[]{expected};
			}
			
			public ErrorSet(int index, string[] expected)
			{
				Index = index;
				Expected = expected;
			}
			
			// The location associated with the errors. For a failed parse this will be the
			// same as State.Index. For a successful parse it will be State.Index or later.
			public int Index;
			
			// This will be the name of something which was expected, but not found.
			public string[] Expected;
			
			public static ErrorSet Combine(ErrorSet lhs, ErrorSet rhs)
			{
				if (lhs.Index > rhs.Index)
				{
					return lhs;
				}
				else if (lhs.Index < rhs.Index)
				{
					return rhs;
				}
				else
				{
					List<string> errors = new List<string>(lhs.Expected.Length + rhs.Expected.Length);
					errors.AddRange(lhs.Expected);
					foreach (string err in rhs.Expected)
					{
						if (errors.IndexOf(err) < 0)
							errors.Add(err);
					}
					return new ErrorSet(lhs.Index, errors.ToArray());
				}
			}
			
			public override string ToString()
			{
				if (Expected.Length > 0)
					return string.Format("Expected {0}", string.Join(" or ", Expected));
				else
					return "<none>";
			}
		}
		
		// The state of the parser.
		private struct State
		{
			public State(int index, bool parsed)
			{
				Index = index;
				Parsed = parsed;
				Errors = new ErrorSet(index, new string[0]);
			}
			
			public State(int index, bool parsed, ErrorSet errors)
			{
				Index = index;
				Parsed = parsed;
				Errors = errors;
			}
			
			// Index of the first unconsumed character.
			public int Index;
			
			// True if the expression associated with the state successfully parsed.
			public bool Parsed;
			
			// If Parsed is false then this will explain why. If Parsed is true it will
			// say why the parse stopped.
			public ErrorSet Errors;
		}
		
		// The result of parsing a literal or non-terminal.
		private struct Result
		{
			public Result(GoalModelParser parser, int index, int length, string input, KAOSTools.Parsing.ParsedElement value)
			{
				m_parser = parser;
				m_index = index;
				m_length = length;
				m_input = input;
				Value = value;
			}
			
			// The text which was parsed by the terminal or non-terminal.
			public string Text {get {return m_input.Substring(m_index, m_length);}}
			
			// The 1-based line number the (non)terminal started on.
			public int Line {get {return m_parser.DoGetLine(m_index);}}
			
			// The 1-based column number the (non)terminal started on.
			public int Col {get {return m_parser.DoGetCol(m_index);}}
			
			// For non-terminals this will be the result of the semantic action, 
			// otherwise it will be the default value.
			public KAOSTools.Parsing.ParsedElement Value;
			
			private GoalModelParser m_parser;
			private int m_index;
			private int m_length;
			private string m_input;
		}
		
		#endregion
		
		#region Fields
		private string m_input;
		private string m_file;
		private Dictionary<string, ParseMethod[]> m_nonterminals = new Dictionary<string, ParseMethod[]>();
		private Dictionary<CacheKey, CacheValue> m_cache = new Dictionary<CacheKey, CacheValue>();
		#endregion
	}
}
