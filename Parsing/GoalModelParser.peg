start = Start
value = KAOSTools.Parsing.ParsedElement
namespace = KAOSTools.Parsing
visibility = public
debug = 

Start := S Elements S;

Elements := 
    ( ( System / Predicate / Goal / DomProp / Obstacle / Agent / Import / DomHyp 
        / Entity / Type / Association ) S )*
    `value = BuildElements (results);`

Import := 
    'import' S '"' String '"' 
    `value = Import(results[2].Text);`
    
# First-class declarations
    
Predicate := 
    ( 'declare' / 'override' ) S 'predicate' S (PredicateAttribute S)* 'end' 
    `value = BuildPredicate(results);`

System := 
    ( 'declare' / 'override' ) S 'system' S (SystemAttribute S)* 'end' 
    `value = BuildSystem(results);`
    
Goal := 
    ( 'declare' / 'override' ) S 'goal' S (GoalAttribute S)* 'end'
    `value = BuildGoal(results);`
    
DomProp := 
    ( 'declare' / 'override' ) S ('domainproperty' / 'domprop' ) S (DomPropAttribute S)* 'end'
    `value = BuildDomainProperty(results);`
    
Obstacle := 
    ( 'declare' / 'override' ) S 'obstacle' S (ObstacleAttribute S)* 'end'
    `value = BuildObstacle(results);`

Agent := 
    ( 'declare' / 'override' ) S 'agent' S (AgentAttribute S)* 'end'
    `value = BuildAgent(results);`

DomHyp := 
    ( 'declare' / 'override' ) S ('domainhypothesis' / 'domhyp' ) S (DomHypAttribute S)* 'end'
    `value = BuildDomainHypothesis(results);`

Entity := 
    ( 'declare' / 'override' ) S ( 'entity' / 'object' ) S (EntityAttribute S)* 'end'
    `value = BuildEntity(results);`

Type := 
    ( 'declare' / 'override' ) S 'type' S (TypeAttribute S)* 'end'
    `value = BuildType(results);`

Association := 
    ( 'declare' / 'override' ) S ( 'association' / 'relation' ) S (AssociationAttribute S)* 'end'
    `value = BuildAssociation(results);`
    
# Attribute collection
                                                                                                                                                                                                         
GoalAttribute := 
    ( IdAttribute / NameAttribute / DefinitionAttribute / FormalSpecAttribute / RefinedByGoal 
      / ObstructedBy / AssignedTo / RDSAttribute )
    `value = results[0].Value;`
    
DomPropAttribute := 
    ( IdAttribute / NameAttribute / DefinitionAttribute / FormalSpecAttribute / Probability )
    `value = results[0].Value;`
    
DomHypAttribute := 
    ( IdAttribute / NameAttribute / DefinitionAttribute )
    `value = results[0].Value;`

ObstacleAttribute := 
    ( IdAttribute / NameAttribute / DefinitionAttribute / FormalSpecAttribute / RefinedByObstacle 
      / ResolvedBy / Probability )
    `value = results[0].Value;`

AgentAttribute := 
    ( IdAttribute / NameAttribute / DefinitionAttribute / AgentTypeAttribute )
    `value = results[0].Value;`
                                                                         
PredicateAttribute := 
    ( IdAttribute / NameAttribute / DefinitionAttribute / SignatureAttribute / Argument 
      / FormalSpecAttribute ) 
    `value = results[0].Value;`

SystemAttribute := 
    ( IdAttribute / NameAttribute / DefinitionAttribute / AlternativeAttribute ) 
    `value = results[0].Value;`

EntityAttribute := 
    ( IdAttribute / NameAttribute / DefinitionAttribute / Attribute / IsA / EntityTypeAttribute ) 
    `value = results[0].Value;`
    
TypeAttribute := 
    ( IdAttribute / NameAttribute / DefinitionAttribute ) 
    `value = results[0].Value;`
    
AssociationAttribute :=
    ( IdAttribute / NameAttribute / DefinitionAttribute / Attribute / Link ) 
    `value = results[0].Value;`
    
# Attributes

IdAttribute := 'id' S Identifier
    `value = BuildIdentifierAttribute(results);`

NameAttribute := 'name' S '"' String? '"'
    `value = BuildNameAttribute(results);`
    
SignatureAttribute := 'signature'  S '"' String? '"'
    `value = BuildSignatureAttribute(results);`
    
FormalSpecAttribute := 'formalspec' S '"' Formula? '"' 
    `value = BuildFormalSpecAttribute(results);`
    
DefinitionAttribute := 'definition' S '"' String? '"' 
    `value = BuildDefinitionAttribute(results);`

RDSAttribute := 'rds' S Float 
    `value = BuildRDS(results);`

Probability := ('probability' / 'eps') S Float 
    `value = BuildProbability(results);`

ObstructedBy := 'obstructedby' S ( Obstacle / Name / Identifier ) 
    `value = BuildObstructedBy(results);`
    
ResolvedBy := 'resolvedby' S ( Goal / Name / Identifier )
    `value = BuildResolvedBy(results);`
        
AlternativeAttribute := 'alternative' S ( System / Name / Identifier ) 
    `value = BuildAlternativeAttribute(results);`

IsA := 'is' S ( Entity / Name / Identifier )
    `value = BuildIsA(results);`
                                                                         

AgentTypeAttribute := 'type' S ( 'software' / 'environment' )
    `value = BuildAgentTypeAttribute (results);`
    
EntityTypeAttribute := 'type' S ( 'software' / 'environment' / 'shared' )
    `value = BuildEntityTypeAttribute (results);`
    
    
RefinedByObstacle := 
    'refinedby' S 
    ( Obstacle / DomProp / DomHyp / Name / Identifier ) 
    (S ',' S ( Obstacle / DomProp / DomHyp / Name / Identifier ) )*
    `value = BuildRefinedBy(results);`
    
RefinedByGoal := 
    'refinedby' ('[' S ( Name / Identifier ) S ']')? S 
    ( Goal / DomProp / DomHyp / Name / Identifier ) 
    (S ',' S ( Goal / DomProp / DomHyp / Name / Identifier ) )*
    `value = BuildRefinedBy(results);`
    
AssignedTo := 
    'assignedto' ('[' S ( Name / Identifier ) S ']')? S 
    ( Agent / Name / Identifier ) (S ',' S ( Agent / Name / Identifier ) )*
    `value = BuildAssignedTo(results);`


Attribute := 'attribute' S Name S (':' S ( Type / Name / Identifier ) )?
    `value = BuildAttribute(results);`

Argument := 'argument' S Identifier S (':' S ( Entity / Name / Identifier ) )?
    `value = BuildArgument(results);`

Link := 'link' S Multiplicity? S ( Entity / Name / Identifier )
    `value = BuildLink(results);`

    
# Expressions                                

Multiplicity :=
    '(' S MultiplicityLowerBound S ('..' S MultiplicityUpperBound S )? ')'
    `value = BuildMultiplicity(results);`

MultiplicityLowerBound := 
    ( [0-9] / 'M' / 'N' )
    `value = results[0].Value;`

MultiplicityUpperBound := 
    ( [0-9] / 'M' / 'N' / '*' )
    `value = results[0].Value;`

Identifier := [a-zA-Z0-9$_-]+
    `value = BuildIdentifier(results);`

Name := '"' String '"' 
    `value = BuildName(results);`

String := ( ( '""' / [^"] )+ )
    `value = null` `expected = "string"`
    
Float := ('.' [0-9]+) / ( [0-9]+ ('.' [0-9]+)? )
    `value = null` `expected = "float"`

# Formal specification

Formula := 
    'forall' S Identifier S ':' S Identifier ( ',' S Identifier S ':' S Identifier )* S '.' S Formula
    / 'exists' S Identifier S ':' S Identifier ( ',' S Identifier S ':' S Identifier )* S '.' S Formula
    / StrongBinary
    `value = BuildFormula(results);`

StrongBinary :=
    'when' S Binary S 'then' S Formula
    / Binary
    `value = BuildStrongBinary(results);`

Binary :=
    'if' S TemporalBinary S 'then' S Formula
    / TemporalBinary S 'iff' S Formula
    / TemporalBinary
    `value = BuildBinary(results);`

TemporalBinary :=
    And S 'until' S Formula
    / And S 'release' S Formula
    / And S 'unless' S Formula
    / And
    `value = BuildTemporalBinary(results);`

And :=
    Or S 'and' S Formula
    / Or
    `value = BuildAnd(results);`

Or := 
    Unary S 'or' S Formula
    / Unary
    `value = BuildOr(results);`

Unary :=
    'not' S Formula
    / 'next' S Formula
    / ('sooner-or-later' / 'eventually') S Formula
    / ('always' / 'globally') S Formula
    / Atom
    `value = BuildUnary(results);`

Atom :=
    '(' S Identifier ( S ',' S Identifier )* S ')' S 'in' S Identifier
    / Identifier ( S '(' S Identifier ( S ',' S Identifier )* S ')' )
    / Identifier '.' Identifier ( S ( '==' / '!=' / '>=' / '<=' / '>' / '<' ) S ( Identifier '.' Identifier / '\'' SingleQuoteString '\'' / Number ) )?
    / Identifier
    / '(' S Formula S ')'
    `value = BuildAtom(results);`

SingleQuoteString := ( ( '\'\'' / [^'] )+ )
    `value = null` `expected = "string"`

Number := ( '.' [0-9]+ / [0-9]+ ( '.' [0-9]+ )? )
    `value = null` `expected = "string"`

# Spaces and comments

S := (Space* Comment+ Space*)+ / Space* `text = null`
Space := [ \t\r\n] `;` `expected = "whitespace"`
Comment := '#' [^\r\n]* `text = null`
